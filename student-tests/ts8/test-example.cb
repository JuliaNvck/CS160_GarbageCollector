// multiple stack frames
// multiple levels of indirection
// aliasing
//
//
// heap size | result |
// ----------+--------+
//      3784 | fin    |
//      3786 | oom    |

fn main() -> int {
  let a:[[int]], b:[[int]], c:&int, i:int;

  a = [[int]; 41];
  b = [[int]; 41];
  c = new int;

  if a[40] != nil or b[40] != nil or c.* != 0 { return 0; }

  while i < 41 {
    a[i] = [int; 41];
    b[i] = a[i];
    i = i + 1;
  }

  return foo(a);
}

fn foo(p:[[int]]) -> int {
  return bar(p);
}

fn bar(p:[[int]]) -> int {
  let i:int;

  p = [[int]; 41];
  while i < 41 {
    p[i] = [int; 41];
    p[i] = nil;
    i = i + 1;
  }

  p[0] = [int; 42];

  return 0;
}
