// one stack frame
// many levels of indirection
// no aliasing
//
// heap size | result |
// ----------+--------+
//        78 | fin    |
//        72 | oom    |

struct list {
  f1: int,
  f2: &list
}

fn main() -> int {
  let a:&list, b:&list, c:&list, d:&list, i:int;

  a = new list;
  b = a;

  if a.f1 != 0 or a.f2 != nil { return 0; }

  c = new list;
  d = c;

  while i < 11 {
    b.f2 = new list;
    b = b.f2;
    b.f1 = i;
    i = i + 1;
  }

  b = nil;
  i = 0;

  while i < 11 {
    a = a.f2;
    d.f2 = new list;
    d = d.f2;
    d.f1 = i * 2;
    i = i + 1;
  }

  a = nil;
  a = new list;

  return 0;
}
