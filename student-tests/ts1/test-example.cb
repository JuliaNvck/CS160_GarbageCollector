// one stack frame
// one level of indirection
// no aliasing
//
// heap size | result |
// ----------+--------+
//        16 | fin    |
//        8  | oom    |

struct foo {
	val1: int,
	val2: int,
	val3: int
}

fn main() -> int {
	let a: &foo, b: &foo, c: [int], d: [int];
	
	//allocate 2 words
	c = [int ; 1];
	
	//mark those 2 words for gc
	c = nil;
	
	a = new foo;	//should trigger gc on 8 word heap
	a = nil;
	
	c = [int ; 1];	//should trigger gc on 8 word heap, and trigger gc on 32 word heap
	d = [int ; 1];
	
	c = nil;
	
	c = [int ; 1];	//should trigger gc on 8 word heap
	a = new foo;	//should trigger gc on 8 word heap and run out of memory, and trigger gc on 32 word heap
	
	return 0;
}