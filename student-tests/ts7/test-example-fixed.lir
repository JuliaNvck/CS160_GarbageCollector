funptr foo: &(int) -> int

fn foo(p:int) -> int {
let _const_0:int, _const_1:int, _const_2:int, _inner3:&&int, _tmp1:int, _tmp2:[&int], _tmp4:&int, _tmp5:int, a:[&int], b:&int

entry:
  _const_0 = $const 0
  _const_1 = $const 1
  _const_2 = $const 2
  _tmp1 = $cmp eq p _const_0
  $branch _tmp1 lbl1 lbl2

lbl1:
  $ret _const_0

lbl2:
  $jump lbl3

lbl3:
  a = $alloc_array _const_2 &int
  _inner3 = $gep a _const_0 [true]
  _tmp4 = $load _inner3
  _tmp1 = $cmp ne _tmp4 __NULL
  _tmp4 = $copy __NULL
  $branch _tmp1 lbl4 lbl5

lbl4:
  $ret _const_0

lbl5:
  $jump lbl6

lbl6:
  _tmp4 = $alloc_single int
  _inner3 = $gep a _const_0 [true]
  $store _inner3 _tmp4
  _tmp4 = $copy __NULL
  _inner3 = $gep a _const_0 [true]
  $store _inner3 __NULL
  _tmp4 = $alloc_single int
  _inner3 = $gep a _const_1 [true]
  $store _inner3 _tmp4
  _tmp4 = $copy __NULL
  _tmp1 = $arith sub p _const_1
  _tmp5 = $call foo(_tmp1)
  $ret _tmp5
}

fn main() -> int {
let _const_0:int, _const_6:int

entry:
  _const_0 = $const 0
  _const_6 = $const 6
  $call foo(_const_6)
  $ret _const_0
}

